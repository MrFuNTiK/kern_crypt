/**
 * @file cipher_ecb.с
 * @author Kirill Voevodin.
 * @brief KAT-тесты XLPS-шифратора в режиме ECB.
 * @version 0.1
 * @date 2025-11-30
 * 
 * @copyright Copyright (c) 2025
 * 
 */

#include <linux/errno.h>
#include <linux/slab.h>
#include <crypto.h>
#include "cipher_ecb.h"

#define KC_STRINGIZE(val) #val

#define KC_EVAL_CHECK_RET(call)                                                \
	do {                                                                   \
		ret = call;                                                    \
		if (ret != 0) {                                                \
			printk(KERN_ERR #call " failed\n");                    \
			goto end;                                              \
		}                                                              \
	} while (0);

#define KC_EVAL_CHECK_NULL(res, call)                                          \
	do {                                                                   \
		res = call;                                                    \
		if (res == NULL) {                                             \
			printk(KERN_ERR #call " failed\n");                    \
			ret = -ENOMEM;                                         \
			goto end;                                              \
		}                                                              \
	} while (0);

static uint8_t test_plain_text[96] = {
	0x0,  0x1,  0x2,  0x3,	0x4,  0x5,  0x6,  0x7,	0x8,  0x9,  0xa,  0xb,
	0xc,  0xd,  0xe,  0xf,	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
	0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
	0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
	0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
	0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
};

static uint8_t test_cipher_text[128] = {
	0x16, 0xe7, 0x95, 0xb2, 0x13, 0xb4, 0xcf, 0xbd, 0x8a, 0x7e, 0x4a, 0x77,
	0x3f, 0x5a, 0xbd, 0x8f, 0xec, 0xc7, 0xd3, 0x7f, 0xcf, 0xdf, 0x29, 0x29,
	0x25, 0xd6, 0xb8, 0x58, 0xcf, 0xd2, 0xc3, 0x19, 0x68, 0xb1, 0x53, 0xe2,
	0x4f, 0x2a, 0xf7, 0xb,	0x2a, 0x54, 0xca, 0x0,	0x35, 0xea, 0xce, 0xf0,
	0x65, 0x9b, 0x9a, 0x28, 0x5,  0x8e, 0xec, 0x5e, 0xa7, 0x7b, 0xcb, 0xbb,
	0xa0, 0xc1, 0xda, 0x56, 0x3,  0x48, 0x8f, 0x9,	0xef, 0x50, 0x13, 0x2,
	0x32, 0x75, 0xe8, 0xba, 0x32, 0xcc, 0x12, 0x3f, 0xf2, 0xd5, 0x2d, 0x9,
	0x86, 0x14, 0xbb, 0xab, 0xa0, 0x12, 0xff, 0x14, 0x99, 0x53, 0x5f, 0x81,
	0x51, 0x9a, 0xe1, 0x1,	0x86, 0x4,  0x91, 0x98, 0xc4, 0xb,  0x4e, 0x2b,
	0xa1, 0xbf, 0x68, 0x5f, 0xe6, 0x1f, 0xad, 0xfd, 0xe2, 0x9b, 0xd4, 0x37,
	0x28, 0x87, 0x83, 0x18, 0xf5, 0x9b, 0xd4, 0x5c,

};

static uint8_t test_key[64] = {
	0x47, 0x4c, 0x57, 0xb4, 0x38, 0x1b, 0x64, 0xb8, 0xc4, 0x28, 0x1e,
	0x68, 0xcf, 0x93, 0xb4, 0x9e, 0xc5, 0xff, 0xb6, 0xba, 0xfe, 0x13,
	0x95, 0x14, 0x95, 0x47, 0x04, 0x52, 0x71, 0x70, 0x2f, 0x9a, 0x6a,
	0x16, 0x71, 0x26, 0x12, 0xa9, 0xd0, 0x52, 0xfd, 0x7f, 0xb2, 0x81,
	0x72, 0x0e, 0x82, 0xb2, 0xbe, 0x31, 0x49, 0x60, 0xb1, 0x8a, 0xb2,
	0x70, 0x2a, 0xc9, 0x3e, 0xd0, 0x85, 0x93, 0x66, 0xf9,
};

int kc_run_kat_cipher_ecb(void)
{
	int ret;
	kc_cipher_t *encryptor;
	kc_cipher_t *decryptor;
	const kc_cipher_param_t *param;
	uint8_t buf[128];
	size_t written;

	memset(buf, 0, sizeof(buf));

	KC_EVAL_CHECK_NULL(encryptor, kc_cipher_create(kc_cipher_ecb()));
	KC_EVAL_CHECK_NULL(decryptor, kc_cipher_create(kc_cipher_ecb()));

	KC_EVAL_CHECK_NULL(param, kc_cipher_param(encryptor));

	KC_EVAL_CHECK_RET(
		kc_cipher_init(encryptor, kc_cipher_op_encrypt, test_key));
	KC_EVAL_CHECK_RET(kc_cipher_update(encryptor, test_plain_text,
					   sizeof(test_plain_text), buf,
					   &written));
	if (written != param->block_size) {
		printk(KERN_ERR
		       "%d: write missmatch: expected = %zu, actual = %zu\n",
		       __LINE__, written, param->block_size);
		ret = -ERANGE;
		goto end;
	}

	KC_EVAL_CHECK_RET(
		kc_cipher_final(encryptor, NULL, 0, buf + written, &written));
	if (written != param->block_size) {
		printk(KERN_ERR
		       "%d: write missmatch: expected = %zu, actual = %zu\n",
		       __LINE__, written, param->block_size);
		ret = -ERANGE;
		goto end;
	}
	written = 0;

	if (memcmp(buf, test_cipher_text, sizeof(test_cipher_text))) {
		printk(KERN_ERR "encrypted text does not match ciphertext\n");
		ret = -EINVAL;
		goto end;
	}

	memset(buf, 0, sizeof(buf));

	KC_EVAL_CHECK_RET(
		kc_cipher_init(decryptor, kc_cipher_op_decrypt, test_key));
	KC_EVAL_CHECK_RET(kc_cipher_update(decryptor, test_cipher_text,
					   sizeof(test_cipher_text), buf,
					   &written));
	if (written != 2 * param->block_size) {
		printk(KERN_ERR
		       "%d: write missmatch: expected = %zu, actual = %zu\n",
		       __LINE__, written, param->block_size);
		ret = -ERANGE;
		goto end;
	}

	KC_EVAL_CHECK_RET(
		kc_cipher_final(decryptor, NULL, 0, buf + written, &written));
	if (written != 0) {
		printk(KERN_ERR
		       "%d: write missmatch: expected = %zu, actual = %zu\n",
		       __LINE__, written, param->block_size);
		ret = -ERANGE;
		goto end;
	}

	if (memcmp(buf, test_plain_text, sizeof(test_plain_text))) {
		printk(KERN_ERR "decrypted text does not match plaintext\n");
		ret = -EINVAL;
		goto end;
	}

	ret = 0;
end:
	kc_cipher_destroy(encryptor);
	kc_cipher_destroy(decryptor);
	return ret;
}